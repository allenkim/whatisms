generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model PlaidItem {
  id                 String    @id @default(cuid())
  itemId             String    @unique // Plaid's item_id
  accessToken        String    // Plaid access token (keep secure!)
  institution        String    // Institution name for display
  accounts           Account[]
  transactionsCursor String?   // Cursor for incremental transaction sync
  lastSynced         DateTime?
  lastTransactionSync DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
}

model SnapTradeConnection {
  id              String    @id @default(cuid())
  userId          String    // SnapTrade userId (same for all connections in single-user app)
  userSecret      String    // SnapTrade userSecret (keep secure)
  authorizationId String    @unique
  institution     String
  accounts        Account[]
  lastSynced      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Account {
  id                     String               @id @default(cuid())
  name                   String
  institution            String
  type                   String               // BANK, BROKERAGE, CRYPTO_EXCHANGE, REAL_ESTATE, OTHER
  plaidItemId            String?
  plaidItem              PlaidItem?           @relation(fields: [plaidItemId], references: [id], onDelete: SetNull)
  plaidAccountId         String?              // Plaid's account_id for this specific account
  snapTradeConnectionId  String?
  snapTradeConnection    SnapTradeConnection? @relation(fields: [snapTradeConnectionId], references: [id], onDelete: SetNull)
  snapTradeAccountId     String?              // SnapTrade's account UUID
  holdings               Holding[]
  transactions           Transaction[]
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt
}

model Holding {
  id                String      @id @default(cuid())
  accountId         String
  account           Account     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  name              String
  ticker            String?
  category          String      // STOCK, BOND, CASH, CRYPTO, REAL_ESTATE, ETF, MUTUAL_FUND, OTHER
  quantity          Float
  price             Float
  value             Float
  plaidSecurityId   String?     // Plaid's security_id for syncing
  snapTradeSymbolId String?     // SnapTrade's symbol ID for syncing
  costBasis         CostBasis[] // Purchase history for performance tracking
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
}

model Transaction {
  id                 String   @id @default(cuid())
  accountId          String
  account            Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  plaidTransactionId String   @unique // Plaid's transaction_id
  name               String   // Merchant name or description
  merchantName       String?  // Clean merchant name from Plaid
  amount             Float    // Positive = money out, negative = money in
  category           String   // Plaid category (e.g., "Food and Drink", "Shopping")
  subcategory        String?  // Plaid subcategory
  date               DateTime // Transaction date
  pending            Boolean  @default(false)
  isRecurring        Boolean  @default(false) // Detected as recurring
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([accountId, date])
  @@index([category])
  @@index([merchantName])
}

model Snapshot {
  id        String            @id @default(cuid())
  netWorth  Float
  holdings  SnapshotHolding[]
  createdAt DateTime          @default(now())
}

model SnapshotHolding {
  id         String   @id @default(cuid())
  snapshotId String
  snapshot   Snapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  name       String
  category   String
  value      Float
}

// Budget Goals - monthly spending limits per category
model BudgetGoal {
  id        String   @id @default(cuid())
  category  String   @unique // Spending category (matches Transaction.category)
  limit     Float    // Monthly spending limit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Bill Reminders - track recurring bills
model Bill {
  id        String    @id @default(cuid())
  name      String    // Bill name (e.g., "Netflix", "Electric Bill")
  amount    Float     // Expected amount
  dueDay    Int       // Day of month (1-31)
  category  String    // Category for grouping
  isPaid    Boolean   @default(false) // Paid this month
  paidDate  DateTime? // When it was paid
  isAutoPay Boolean   @default(false) // Auto-pay enabled
  notes     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

// Credit Score History
model CreditScore {
  id        String   @id @default(cuid())
  score     Int      // Credit score (300-850)
  source    String   // Where the score came from (manual, experian, etc.)
  createdAt DateTime @default(now())
}

// Investment cost basis for performance tracking
model CostBasis {
  id            String   @id @default(cuid())
  holdingId     String
  holding       Holding  @relation(fields: [holdingId], references: [id], onDelete: Cascade)
  purchaseDate  DateTime
  purchasePrice Float    // Price per unit at purchase
  quantity      Float    // Quantity purchased
  createdAt     DateTime @default(now())
}

// AI-generated insights
model Insight {
  id        String   @id @default(cuid())
  type      String   // SPENDING_ANOMALY, WEEKLY_SUMMARY, BUDGET_ALERT, RECURRING_DETECTED
  title     String
  message   String
  severity  String   // INFO, WARNING, ALERT
  isRead    Boolean  @default(false)
  data      String?  // JSON data for additional context
  createdAt DateTime @default(now())
}
